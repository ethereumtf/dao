"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServerlessEventHandler = void 0;
const helpers_1 = require("./helpers");
const http_1 = require("http");
// @ts-expect-error
const dynamic_import_js_1 = require("./dynamic-import.js");
const utils_1 = require("../utils");
const build_utils_1 = require("@vercel/build-utils");
const exit_hook_1 = __importDefault(require("exit-hook"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const async_listen_1 = __importDefault(require("async-listen"));
async function createServerlessServer(userCode, options) {
    const server = http_1.createServer(async (req, res) => {
        if (options.shouldAddHelpers)
            await helpers_1.addHelpers(req, res);
        return userCode(req, res);
    });
    exit_hook_1.default(() => server.close());
    return { url: await async_listen_1.default(server) };
}
async function compileUserCode(entrypointPath, options) {
    let fn = options.useRequire
        ? require(entrypointPath)
        : await dynamic_import_js_1.dynamicImport(entrypointPath);
    /**
     * In some cases we might have nested default props due to TS => JS
     */
    for (let i = 0; i < 5; i++) {
        if (fn.default)
            fn = fn.default;
    }
    return fn;
}
async function createServerlessEventHandler(entrypointPath, options) {
    const userCode = await compileUserCode(entrypointPath, options);
    const server = await createServerlessServer(userCode, options);
    return async function (request) {
        const url = new URL(request.url ?? '/', server.url);
        const response = await node_fetch_1.default(url, {
            body: await utils_1.serializeBody(request),
            headers: {
                ...request.headers,
                host: request.headers['x-forwarded-host'],
            },
            method: request.method,
            redirect: 'manual',
        });
        let body;
        if (options.mode === 'streaming') {
            body = response.body;
        }
        else {
            body = await build_utils_1.streamToBuffer(response.body);
            response.headers.delete('transfer-encoding');
            //@ts-expect-error
            response.headers.set('content-length', body.length);
        }
        return {
            status: response.status,
            headers: response.headers,
            body,
            encoding: 'utf8',
        };
    };
}
exports.createServerlessEventHandler = createServerlessEventHandler;
