"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEdgeEventHandler = void 0;
const edge_wasm_plugin_1 = require("./edge-wasm-plugin");
const edge_node_compat_plugin_1 = require("./edge-node-compat-plugin");
const edge_runtime_1 = require("edge-runtime");
const node_fetch_1 = __importStar(require("node-fetch"));
const error_utils_1 = require("@vercel/error-utils");
const fs_1 = require("fs");
const utils_1 = require("../utils");
const esbuild_1 = __importDefault(require("esbuild"));
const exit_hook_1 = __importDefault(require("exit-hook"));
const url_1 = require("url");
const NODE_VERSION_MAJOR = process.version.match(/^v(\d+)\.\d+/)?.[1];
const NODE_VERSION_IDENTIFIER = `node${NODE_VERSION_MAJOR}`;
if (!NODE_VERSION_MAJOR) {
    throw new Error(`Unable to determine current node version: process.version=${process.version}`);
}
const edgeHandlerTemplate = fs_1.readFileSync(`${__dirname}/edge-handler-template.js`);
async function compileUserCode(entrypointFullPath, entrypointRelativePath, isMiddleware) {
    const { wasmAssets, plugin: edgeWasmPlugin } = edge_wasm_plugin_1.createEdgeWasmPlugin();
    const nodeCompatPlugin = edge_node_compat_plugin_1.createNodeCompatPlugin();
    try {
        const result = await esbuild_1.default.build({
            // bundling behavior: use globals (like "browser") instead
            // of "require" statements for core libraries (like "node")
            platform: 'browser',
            // target syntax: only use syntax available on the current
            // version of node
            target: NODE_VERSION_IDENTIFIER,
            sourcemap: 'inline',
            legalComments: 'none',
            bundle: true,
            plugins: [
                edgeWasmPlugin,
                nodeCompatPlugin.plugin,
                {
                    name: 'import.meta.url',
                    setup({ onLoad }) {
                        onLoad({ filter: /\.[cm]?js$/, namespace: 'file' }, args => {
                            let code = fs_1.readFileSync(args.path, 'utf8');
                            code = code.replace(/\bimport\.meta\.url\b/g, JSON.stringify(url_1.pathToFileURL(__filename)));
                            return { contents: code };
                        });
                    },
                },
            ],
            entryPoints: [entrypointFullPath],
            write: false,
            format: 'cjs',
        });
        const compiledFile = result.outputFiles?.[0];
        if (!compiledFile) {
            throw new Error(`Compilation of ${entrypointRelativePath} produced no output files.`);
        }
        const userCode = `
      // strict mode
      "use strict";var regeneratorRuntime;

      // user code
      ${compiledFile.text};
      const userEdgeHandler = module.exports.default;
      if (!userEdgeHandler) {
        throw new Error(
          'No default export was found. Add a default export to handle requests. Learn more: https://vercel.link/creating-edge-middleware'
        );
      }

      // request metadata
      const isMiddleware = ${isMiddleware};
      const entrypointLabel = '${entrypointRelativePath}';

      // edge handler
      ${edgeHandlerTemplate};
      const dependencies = { Request, Response };
      const options = { isMiddleware, entrypointLabel };
      registerFetchListener(userEdgeHandler, options, dependencies);
    `;
        return {
            userCode,
            wasmAssets,
            nodeCompatBindings: nodeCompatPlugin.bindings,
        };
    }
    catch (error) {
        // We can't easily show a meaningful stack trace from ncc -> edge-runtime.
        // So, stick with just the message for now.
        console.error(`Failed to compile user code for edge runtime.`);
        if (error_utils_1.isError(error))
            utils_1.logError(error);
        return undefined;
    }
}
async function createEdgeRuntimeServer(params) {
    try {
        if (!params) {
            return undefined;
        }
        const wasmBindings = await params.wasmAssets.getContext();
        const nodeCompatBindings = params.nodeCompatBindings.getContext();
        const runtime = new edge_runtime_1.EdgeRuntime({
            initialCode: params.userCode,
            extend: context => {
                Object.assign(context, {
                    // This is required for esbuild wrapping logic to resolve
                    module: {},
                    // This is required for environment variable access.
                    // In production, env var access is provided by static analysis
                    // so that only the used values are available.
                    process: {
                        env: process.env,
                    },
                    // These are the global bindings for Node.js compatibility
                    ...nodeCompatBindings,
                    // These are the global bindings for WebAssembly module
                    ...wasmBindings,
                });
                return context;
            },
        });
        const server = await edge_runtime_1.runServer({ runtime });
        exit_hook_1.default(() => server.close());
        return server;
    }
    catch (error) {
        // We can't easily show a meaningful stack trace from ncc -> edge-runtime.
        // So, stick with just the message for now.
        console.error('Failed to instantiate edge runtime.');
        utils_1.logError(error);
        return undefined;
    }
}
async function createEdgeEventHandler(entrypointFullPath, entrypointRelativePath, isMiddleware, isZeroConfig) {
    const userCode = await compileUserCode(entrypointFullPath, entrypointRelativePath, isMiddleware);
    const server = await createEdgeRuntimeServer(userCode);
    return async function (request) {
        if (!server) {
            // this error state is already logged, but we have to wait until here to exit the process
            // this matches the serverless function bridge launcher's behavior when
            // an error is thrown in the function
            process.exit(1);
        }
        const headers = new node_fetch_1.Headers(request.headers);
        const body = await utils_1.serializeBody(request);
        if (body !== undefined)
            headers.set('content-length', String(body.length));
        const url = new URL(request.url ?? '/', server.url);
        const response = await node_fetch_1.default(url, {
            body,
            headers,
            method: request.method,
            redirect: 'manual',
        });
        const isUserError = response.headers.get('x-vercel-failed') === 'edge-wrapper';
        if (isUserError && response.status >= 500) {
            const body = await response.text();
            // We can't currently get a real stack trace from the Edge Function error,
            // but we can fake a basic one that is still usefult to the user.
            const fakeStackTrace = `    at (${entrypointRelativePath})`;
            const requestPath = entrypointToRequestPath(entrypointRelativePath, isZeroConfig);
            console.log(`Error from API Route ${requestPath}: ${body}\n${fakeStackTrace}`);
            // this matches the serverless function bridge launcher's behavior when
            // an error is thrown in the function
            process.exit(1);
        }
        return {
            status: response.status,
            headers: response.headers,
            body: response.body,
            encoding: 'utf8',
        };
    };
}
exports.createEdgeEventHandler = createEdgeEventHandler;
function entrypointToRequestPath(entrypointRelativePath, isZeroConfig) {
    // ensure the path starts with a slash to match conventions used elsewhere,
    // notably when rendering serverless function paths in error messages
    return '/' + utils_1.entrypointToOutputPath(entrypointRelativePath, isZeroConfig);
}
